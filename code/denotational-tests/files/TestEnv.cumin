{- Peano Numbers -}

data Peano = Z | S Peano

addPeano :: Peano -> Peano -> Peano
addPeano a b = case a of
  Z -> b
  S r -> S (addPeano r b)

subPeanoDet :: Peano -> Peano -> Peano
subPeanoDet a b = case b of
  Z -> a
  S b' -> case a of
    Z -> failed<:Peano:>
    S a' -> subPeanoDet a' b'

subPeanoFree :: Peano -> Peano -> Peano
subPeanoFree a b = let d :: Peano free in
  guard<:Peano:> (addPeano b d == a) d

multPeano :: Peano -> Peano -> Peano
multPeano m n = case n of
  Z -> Z
  S n' -> addPeano m (multPeano m n')

peanoToNat :: Peano -> Nat
peanoToNat p = case p of
  Z -> 0
  S r -> 1 + peanoToNat r

cmpPeano :: Peano -> Peano -> Ordering
cmpPeano m n = case m of
  Z -> case n of
    Z -> EQ
    S n' -> LT
  S m' -> case n of
    Z -> GT
    S n' -> cmpPeano m' n'

{- Church Numerals -}

churchZ :: forall a.(a -> a) -> a -> a
churchZ f z = z

churchS :: forall a.((a -> a) -> a -> a) -> (a -> a) -> a -> a
churchS n f z = n f (f z)

addChurch :: forall a.((a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a
addChurch m n f z = m f (n f z)

multChurch :: forall a.((a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a
multChurch m n f z = m (n f) z

churchToPeano :: ((Peano -> Peano) -> Peano -> Peano) -> Peano
churchToPeano n = n S Z

peanoToChurch :: forall a. Peano -> (a -> a) -> a -> a
peanoToChurch n f z = case n of
  Z -> z
  S n' -> peanoToChurch<:a:> n' f (f z)

{- Ordering and Comparisons -}

data Ordering = LT | EQ | GT

cmpNat :: Nat -> Nat -> Ordering
cmpNat  n m = cmpNat' n m n m

cmpNat' :: Nat -> Nat -> Nat -> Nat -> Ordering
cmpNat' n m n' m' = case m == n' of
  False -> case n == m' of
    False -> cmpNat' n m (n' + 1) (m' + 1)
    True  -> GT
  True -> case n == m' of
    False -> LT
    True  -> EQ

{- Sorting by Permutations -}

insertAnywhere :: forall a.a -> [a] -> [a]
insertAnywhere x xs = case xs of
  Nil -> [x]<:a:>
  Cons y ys -> choose<:List a:> (Cons<:a:> x xs) (Cons<:a:> y (insertAnywhere<:a:> x ys))

isSorted :: forall a.(a -> a -> Ordering) -> [a] -> Bool
isSorted cmp xs = case xs of
  Nil -> True
  Cons y ys -> isSorted'<:a:> cmp y ys

isSorted' :: forall a.(a -> a -> Ordering) -> a -> [a] -> Bool
isSorted' cmp pred xs = case xs of
  Nil -> True
  Cons y ys -> case cmp pred y of
    GT -> False
    o  -> isSorted'<:a:> cmp y ys

permuted :: forall a. List a -> List a
permuted = foldr<:a,List a:> insertAnywhere<:a:> Nil<:a:>

permSort :: forall a. (a -> a -> Ordering) -> [a] -> [a]
permSort cmp xs = let ys = permuted<:a:> xs in guard<:List a:> (isSorted<:a:> cmp ys) ys

{- Functions on Lists -}

{- repeat only works with iterative deepening search when using unrestricted step index -}
repeat :: forall a. a -> [a]
repeat x = choose<:List a:> Nil<:a:> (Cons<:a:> x (repeat<:a:> x))

{- Einstein -}

data House  = House Color Person Pet Smoke Drink

data Person = Englishman | Spaniard | Ukrainian | Norwegian | Japanese
data Pet    = Dog | Snails | Fox | Zebra | Horse
data Color  = Red | Green | Ivory | Yellow | Blue
data Smoke  = OldGold | Kool | Chesterfield | LuckyStrike | Parliament
data Drink  = Milk | OrangeJuice | Tea | Coffee | Water

data Success = Success

at :: forall a. List a -> Peano -> a
at xs n = case xs of
  Nil -> failed<:a:>
  Cons y ys -> case n of
    Z -> y
    S n' -> at<:a:> ys n'

member :: forall a. Data a => a -> List a -> Bool
member x xs = case xs of
  Nil -> False
  Cons y ys -> or (x == y) (member<:a:> x ys)

all :: forall a. (a -> Bool) -> List a -> Bool
all f xs = foldr<:Bool,Bool:> and True (map<:a,Bool:> f xs)

houses :: List House -> Bool
houses hs =
  let h1 = at<:House:> hs Z in
  let h3 = at<:House:> hs (S (S Z)) in
  let hex = houseExists hs in
  all<:House:> hex houseConstraints

houseExists :: [House] -> House -> Bool
houseExists hs h = member<:House:> h hs

houseConstraints :: [House]
houseConstraints =
  [ House Red Englishman anything<:Pet:> anything<:Smoke:> anything<:Drink:>
  , House anything<:Color:> Spaniard Dog anything<:Smoke:> anything<:Drink:>
  , House Green anything<:Person:> anything<:Pet:> anything<:Smoke:> Coffee
  , House anything<:Color:> Ukrainian anything<:Pet:> anything<:Smoke:> Tea
  , House anything<:Color:> anything<:Person:> Snails OldGold anything<:Drink:>
  , House Yellow anything<:Person:> anything<:Pet:> Kool anything<:Drink:>
  , House anything<:Color:> anything<:Person:> anything<:Pet:> LuckyStrike OrangeJuice
  , House anything<:Color:> Japanese anything<:Pet:> Parliament anything<:Drink:>
  ]<:House:>

puzzle :: [House]
puzzle =
  let h1 :: House free in
  let h2 :: House free in
  let h3 :: House free in
  let h4 :: House free in
  let h5 :: House free in
  let hs = [h1,h2,h3,h4,h5]<:House:> in
  guard<:List House:> (houses hs) hs

anything :: forall a. Data a => a
anything = let x :: a free in x

{-
There are five houses.

The Englishman lives in the red house.
The Spaniard owns the dog.
Coffee is drunk in the green house.
The Ukrainian drinks tea.
The Old Gold smoker owns snails.
Kools are smoked in the yellow house.
The Lucky Strike smoker drinks orange juice.
The Japanese smokes Parliaments.

The green house is immediately to the right of the ivory house.
The man who smokes Chesterfields lives in the house next to the man with the fox.
Kools are smoked in the house next to the house where the horse is kept.
The Norwegian lives next to the blue house.

Milk is drunk in the middle house.
The Norwegian lives in the first house.

-}

{- Benchmarks -}

benchAddPeano :: Peano
benchAddPeano = addPeano (S (S (S Z))) (S (S Z))

benchSubPeanoDet :: Peano
benchSubPeanoDet = subPeanoDet (S (S (S Z))) (S (S Z))

benchSubPeanoFree :: Peano
benchSubPeanoFree = subPeanoFree (S (S (S Z))) (S (S Z))

benchSort :: List Nat
benchSort = permSort<:Nat:> cmpNat [1,5,3,2,4]<:Nat:>
